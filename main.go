package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"sort"
	"time"
)

type RawLine struct {
	Action  string    `json:"Action"`
	Package string    `json:"Package"`
	Test    string    `json:"Test"`
	Output  string    `json:"Output"`
	Time    time.Time `json:"Time"`
}

type id = string

type pkg = string

type test struct {
	pkg      pkg
	name     string
	started  time.Time
	duration time.Duration
	passed   bool
}

type stats struct {
	packageDurations map[pkg]time.Duration
	tests            map[id]*test
}

func newStats() *stats {
	return &stats{
		packageDurations: make(map[pkg]time.Duration),
		tests:            make(map[id]*test),
	}
}

func (s *stats) add(line RawLine) {
	if line.Test == "" {
		return
	}

	id := testId(line.Package, line.Test)

	t, haveT := s.tests[id]

	if !haveT {
		t = &test{
			pkg:  line.Package,
			name: line.Test,
		}
		s.tests[id] = t
	}

	switch line.Action {
	case "run":
		t.started = line.Time
	case "pass":
		t.passed = true
		t.duration = line.Time.Sub(t.started)

		d := s.packageDurations[line.Package]
		s.packageDurations[line.Package] = d + t.duration
	}
}

func (s *stats) testsSortedByDurationDescending() ([]*test, []time.Duration) {
	var ks []*test
	var vs []time.Duration
	for _, v := range s.tests {
		ks = append(ks, v)
		vs = append(vs, v.duration)
	}
	byDurationDesc := func(i, j int) bool {
		return vs[j] < vs[i]
	}
	sort.Slice(ks, byDurationDesc)
	sort.Slice(vs, byDurationDesc)
	return ks, vs

}

func (s *stats) packagesSortedByDurationDescending() ([]pkg, []time.Duration) {
	var ks []pkg
	var vs []time.Duration
	for k, v := range s.packageDurations {
		ks = append(ks, k)
		vs = append(vs, v)
	}
	byDurationDesc := func(i, j int) bool {
		return vs[j] < vs[i]
	}
	sort.Slice(ks, byDurationDesc)
	sort.Slice(vs, byDurationDesc)
	return ks, vs
}

func testId(pkg pkg, name string) id {
	return fmt.Sprintf("%s#%s", pkg, name)
}

func readFile(path string, visitRawLine func(RawLine) error) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	scanner.Split(bufio.ScanLines)

	for scanner.Scan() {
		line := scanner.Text()

		var rawLine RawLine
		err := json.Unmarshal([]byte(line), &rawLine)
		if err != nil {
			return err
		}

		err = visitRawLine(rawLine)
		if err != nil {
			return err
		}
	}

	return nil
}

func computeStatsData(files []string) *stats {
	stats := newStats()
	for _, a := range files {
		err := readFile(a, func(line RawLine) error {
			stats.add(line)
			return nil
		})
		if err != nil {
			log.Fatal(err)
		}
	}
	return stats
}

func main() {
	var statistic string
	flag.StringVar(&statistic, "statistic", "", "Statistic to compute: pkg-time|test-time")
	oldUsage := flag.Usage
	flag.Usage = func() {
		oldUsage()
		fmt.Printf("\nArguments: [file1.json file2.json ... fileN.json]\n\n")
		fmt.Printf("Parses files generated by `go test -json f.json` and computes test set statistics.\n")
	}
	flag.Parse()

	args := flag.Args()

	switch statistic {
	case "":
		fmt.Printf("The `-statistic` flag is required.\n\n")
		flag.Usage()
	case "pkg-time":
		stats := computeStatsData(args)
		pkgs, pkgDurs := stats.packagesSortedByDurationDescending()
		for i, pkg := range pkgs {
			fmt.Printf("%s\t%v\n", pkg, pkgDurs[i])
		}
		return
	case "test-time":
		stats := computeStatsData(args)
		tests, testDurs := stats.testsSortedByDurationDescending()
		for i, t := range tests {
			var status string
			if t.passed {
				status = "pass"
			} else {
				status = "fail"
			}
			fmt.Printf("%s\t%s\t%v\t%s\n", t.name, t.pkg, testDurs[i], status)
		}
		break
	default:
		fmt.Printf("The `-statistic` flag is must be one of `pkg-time`, `test-time`.\n\n")
		flag.Usage()
	}
}
