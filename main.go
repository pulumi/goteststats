package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"sort"
	"time"
)

type id = string

type pkg = string

type RawLine struct {
	Action  string    `json:"Action"`
	Package string    `json:"Package"`
	Test    string    `json:"Test"`
	Output  string    `json:"Output"`
	Time    time.Time `json:"Time"`
}

func (l *RawLine) isValid() bool {
	var time0 time.Time
	return l.Time.After(time0) && l.Test != "" && l.Package != "" && l.Action != ""
}

type test struct {
	pkg      pkg
	name     string
	started  time.Time
	duration time.Duration
	passed   bool
}

type testmap struct {
	tests map[id]*test
}

func (s *testmap) merge(more ...testmap) testmap {
	result := make(map[id]*test)
	for _, x := range append([]testmap{*s}, more...) {
		for k, v := range x.tests {
			result[k] = v
		}
	}
	return testmap{result}
}

func (s *testmap) testsSortedByDurationDescending() []*test {
	var out []*test
	for _, t := range s.tests {
		out = append(out, t)
	}
	sort.Slice(out, func(i, j int) bool { return out[j].duration < out[i].duration })
	return out
}

type pkgdurs struct {
	pkgs map[pkg]time.Duration
}

type pkgdur struct {
	pkg string
	dur time.Duration
}

func (s *pkgdurs) packagesSortedByDurationDescending() []pkgdur {
	var out []pkgdur
	for k, v := range s.pkgs {
		out = append(out, pkgdur{k, v})
	}
	sort.Slice(out, func(i, j int) bool { return out[j].dur < out[i].dur })
	return out
}

func testId(pkg pkg, name string) id {
	return fmt.Sprintf("%s#%s", pkg, name)
}

func readFile(path string) ([]RawLine, error) {
	var lines []RawLine

	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	scanner.Split(bufio.ScanLines)

	var time0 time.Time

	for scanner.Scan() {
		line := scanner.Text()

		var rawLine RawLine
		err := json.Unmarshal([]byte(line), &rawLine)

		if err != nil {
			return nil, err
		}
		if rawLine.Time.After(time0) {
			lines = append(lines, rawLine)
		}
	}

	return lines, nil
}

func newTestmap(lines []RawLine) testmap {
	m := make(map[id]*test)
	for _, line := range lines {
		if !line.isValid() || line.Action != "run" {
			continue
		}
		t := &test{
			pkg:     line.Package,
			name:    line.Test,
			started: line.Time,
		}
		m[testId(line.Package, line.Test)] = t
	}
	for _, line := range lines {
		if !line.isValid() {
			continue
		}
		switch line.Action {
		case "pass":
			t := m[testId(line.Package, line.Test)]
			t.duration = line.Time.Sub(t.started)
			t.passed = true
		case "fail":
			t := m[testId(line.Package, line.Test)]
			t.duration = line.Time.Sub(t.started)
			t.passed = false
		}
	}
	return testmap{m}
}

func newTestmapFromFiles(files []string) testmap {
	m := newTestmap(nil)
	var more []testmap
	for _, a := range files {
		lines, err := readFile(a)
		if err != nil {
			log.Fatal(err)
		}
		more = append(more, newTestmap(lines))
	}
	return m.merge(more...)
}

func computePackageDurations(tm testmap) pkgdurs {
	durs := make(map[pkg]time.Duration)
	for _, t := range tm.tests {
		durs[t.pkg] = durs[t.pkg] + t.duration
	}
	return pkgdurs{durs}
}

func main() {
	var statistic string
	flag.StringVar(&statistic, "statistic", "", "Statistic to compute: pkg-time|test-time")
	oldUsage := flag.Usage
	flag.Usage = func() {
		oldUsage()
		fmt.Printf("\nArguments: [file1.json file2.json ... fileN.json]\n\n")
		fmt.Printf("Parses files generated by `go test -json f.json` and computes test set statistics.\n")
	}
	flag.Parse()

	args := flag.Args()

	switch statistic {
	case "":
		fmt.Printf("The `-statistic` flag is required.\n\n")
		flag.Usage()
	case "pkg-time":
		tm := newTestmapFromFiles(args)
		d := computePackageDurations(tm)
		pkgdurs := d.packagesSortedByDurationDescending()
		for _, pkgdur := range pkgdurs {
			fmt.Printf("%s\t%v\n", pkgdur.pkg, pkgdur.dur)
		}
	case "test-time":
		stats := newTestmapFromFiles(args)
		tests := stats.testsSortedByDurationDescending()
		for _, t := range tests {
			var status string
			if t.passed {
				status = "pass"
			} else {
				status = "fail"
			}
			fmt.Printf("%s\t%s\t%v\t%s\n", t.name, t.pkg, t.duration, status)
		}
	default:
		fmt.Printf("The `-statistic` flag is must be one of `pkg-time`, `test-time`.\n\n")
		flag.Usage()
	}
}
